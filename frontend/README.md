# 🖥️ Frontend – Crypto Market Insight

## 1. 프론트엔드 역할 개요

본 프론트엔드는 가상자산 시장 데이터를
**차트·지표·전략 결과 형태로 시각화**하여
사용자가 시장 흐름과 전략 성과를 직관적으로 이해할 수 있도록 돕는 역할을 합니다.

> UI 구현 자체보다,
> 데이터 요청 흐름, 상태 관리 책임 분리, 비동기 처리 및 에러 대응을
> 명확히 하는 것을 설계 목표로 합니다.

---

## 2. 기술 스택

### Core

`React` `TypeScript` `Vite`

### State Management

`React Query` `Zustand`

### UI / Visualization

`ECharts` `Styled Components`

### Testing

`Vitest` `Testing Library`

---

## 3. 전체 구조 개요

> 상세 코딩 규약은 [CODING_GUIDELINES.md](./CODING_GUIDELINES.md)를 참고하세요.

프론트엔드는 **기능(feature) 단위로 분리된 구조**를 사용합니다.

```bash
src/
├── features/          # 기능별 모듈
│   ├── common/        # 공통 컴포넌트, 훅, 서비스
│   ├── market/        # 시장 데이터, 차트
│   ├── backtest/      # 백테스트 실행/결과
│   └── portfolio/     # 모의 투자
├── pages/             # 라우트 진입점
├── constants/         # 상수 정의
├── utils/             # 유틸리티
└── routes/            # 라우트 설정
```

### 구조 원칙

- 페이지는 라우팅 진입점 역할만 담당
- 실제 로직은 feature 내부로 이동
- 공통 로직은 `common` feature에서 관리

> 기능 확장 시 의존성 증가를 최소화

---

## 4. 데이터 흐름 설계

### 서버 상태 (React Query)

- 서버에서 가져오는 모든 데이터는 React Query로 관리
- 캐싱, 로딩, 에러 상태를 React Query에 위임
- `queryKey`는 **의존성 전체를 포함**하여 명시적으로 구성

> 서버 데이터는 "읽기 전용 상태"로 취급

### 클라이언트 상태 (Zustand)

- UI 상태 (선택값, 필터, 페이지 상태)
- 사용자 설정 (즐겨찾기, 전략 파라미터)

> 서버 상태와 클라이언트 상태를 명확히 분리하여
> 상태 변경의 책임을 단순화

### 상태 관리 요약

| 상태 유형   | 관리 도구       | 예시                      |
| ----------- | --------------- | ------------------------- |
| 서버 데이터 | React Query     | 시세, 캔들, 백테스트 결과 |
| UI 상태     | Zustand         | 필터 선택값, 모달 상태    |
| 폼 입력     | React Hook Form | 전략 파라미터 입력        |

---

## 5. 차트 시각화 설계

- 차트 컴포넌트는 렌더링 책임만 가짐
- 데이터 가공은 hook 또는 feature 레벨에서 수행
- 가격, 지표, 거래량 레이어를 분리하여 구성

### 차트 레이어 구조

| 레이어          | 담당             |
| --------------- | ---------------- |
| Price Layer     | OHLCV 캔들 차트  |
| Indicator Layer | MA, RSI, MACD 등 |
| Volume Layer    | 거래량 바 차트   |

> 차트 로직의 재사용성과 테스트 용이성 확보

---

## 6. 백테스트 UI 흐름

> 전략/파라미터 선택 → 백테스트 실행 요청 → 로딩 표시 → 결과 렌더링

1. 전략 및 파라미터 선택
2. 백테스트 실행 요청
3. 로딩 상태 표시
4. 결과 요약 카드 렌더링
5. 성과 차트 및 지표 표시

> 백테스트 결과는 불변 데이터로 취급하며, 재실행 시에만 갱신

---

## 7. 인증 처리

- OAuth2 기반 로그인
- 인증 토큰은 메모리 기반으로 관리
- API 요청 시 자동으로 Authorization 헤더에 포함

> 인증 구현보다 **도메인 기능과 사용자 흐름**에 집중

---

## 8. 에러 및 로딩 처리

### 에러 처리

| 에러 유형           | 처리 방식          |
| ------------------- | ------------------ |
| 서버 에러 (5xx)     | 공통 Error UI 표시 |
| 비즈니스 에러 (422) | 메시지 중심 노출   |
| 네트워크 에러       | 재시도 옵션 제공   |

- `ErrorBoundary` + `ErrorFallback` 컴포넌트 활용
- React Query의 `onError` 콜백으로 전역 에러 처리

### 로딩 처리

- 페이지 단위 로딩
- 차트/결과 영역 부분 로딩
- Skeleton UI를 통한 UX 개선

---

## 9. 테스트 전략

### 테스트 범위

| 대상          | 테스트 방식          |
| ------------- | -------------------- |
| 비즈니스 로직 | hook 단위 테스트     |
| UI 컴포넌트   | 렌더링 중심 테스트   |
| 통합 테스트   | 페이지 단위 시나리오 |

### Testing Tools

`Vitest` `Testing Library`

---

## 10. 정리

본 프론트엔드는
**데이터 중심 서비스에서 요구되는 상태 관리, 비동기 처리, 시각화 책임을 명확히 분리**하는 것을 목표로 설계되었습니다.

- Feature 기반 폴더 구조
- React Query + Zustand 상태 관리 분리
- ECharts 기반 차트 시각화
- ErrorBoundary 기반 에러 처리

> 포트폴리오 목적이지만, 실제 서비스 환경에서도 확장 가능한 구조를 지향합니다.
